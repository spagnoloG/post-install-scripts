

typeset -U path cdpath fpath manpath

ZSH=/usr/share/oh-my-zsh/
ZSH_THEME="lambda"

plugins=(archlinux
	asdf
	bundler
	docker
	jsontools
	vscode
	web-search
	tig
    fzf-tab
	gitfast
	colored-man-pages
	colorize
	command-not-found
	cp
	dirhistory
	sudo
	zsh-syntax-highlighting
    zsh-autosuggestions)

# Zoxide 
eval "$(zoxide init zsh)"

# History options should be set in .zshrc and after oh-my-zsh sourcing.
# See https://github.com/nix-community/home-manager/issues/177.
HISTSIZE="10000"
SAVEHIST="10000"

HISTFILE="$HOME/.zsh_history"
mkdir -p "$(dirname "$HISTFILE")"

setopt HIST_FCNTL_LOCK
setopt HIST_IGNORE_DUPS
unsetopt HIST_IGNORE_ALL_DUPS
setopt HIST_IGNORE_SPACE
unsetopt HIST_EXPIRE_DUPS_FIRST
setopt SHARE_HISTORY
unsetopt EXTENDED_HISTORY


export EDITOR='nvim'
export MANPAGER="nvim +Man\!"
export TRASH_DIR="$HOME/.trash"

bin_txt() {
    curl -X PUT --data "$1" https://p.spanskiduh.dev
}

bin_file() {
    curl -X PUT --data-binary "@$1" https://p.spanskiduh.dev
}

pdfgrep() {
    # 1. Check for dependencies: fzf and rga
    if ! command -v rga &> /dev/null || ! command -v fzf &> /dev/null; then
        echo "Error: This function requires 'ripgrep-all (rga)' and 'fzf' to be installed."
        return 1
    fi

    # 2. Check for search term
    if [[ -z "$1" ]]; then
        echo "Usage: pdfgrep <search-term>"
        return 1
    fi
    
    # 3. Run the search and pipe to a more robust fzf command
    rga --ignore-case --pretty --max-depth 1 -t pdf "$1" . | \
    fzf --ansi \
        --delimiter ':' \
        --preview-window 'right,60%,border-left' \
        --bind "enter:execute(xdg-open {1} > /dev/null 2>&1)" \
        --preview "echo {} | cut -d: -f4- | sed 's/\x1b\[[0-9;]*m//g'"
}

_move_to_trash () {
    mkdir -p "$TRASH_DIR"

    for item in "$@"; do
        # Skip options like -r, -f
        if [[ $item == -* ]]; then
            continue
        fi

        # Check if the file or directory exists
        if [[ -e $item ]]; then
            base_name=$(basename "$item")
            target="$TRASH_DIR/$base_name"
            
            # Handle name conflict
            if [[ -e $target ]]; then
                timestamp=$(date +"%Y%m%d%H%M%S")
                target="${TRASH_DIR}/${base_name}_${timestamp}"
            fi

            mv "$item" "$target"
            echo "Moved $item to $target"
        else
            echo "move_to_trash: $item: No such file or directory"
        fi
    done
}

sync_code() {
    local server_name="$1"
    local src_dir="$SRC_DIR"
    local dst_dir="$DST_DIR"
    local exit_code=0
    
    if [[ -z "$server_name" ]]; then
        echo "USAGE: sync_code <server_name> - Synchronizes files from source to destination using rsync/tar+ssh" >&2
        echo "" >&2
        echo "REQUIRED:" >&2
        echo "  server_name  SSH server name to sync to" >&2
        echo "" >&2
        echo "ENVIRONMENT VARIABLES:" >&2
        echo "  SRC_DIR      Source directory (required)" >&2
        echo "  DST_DIR      Destination directory (required)" >&2
        echo "  IGNORE_DIRS  Comma-separated list of directories to exclude (optional)" >&2
        echo "               Example: IGNORE_DIRS=\".venv,.git,results\"" >&2
        return 1
    fi
    
    if [[ -n "$DST_DIR" ]]; then
        dst_dir="${server_name}:${DST_DIR}"
        echo "INFO: Using server '$server_name' with destination '$dst_dir'"
    fi
    
    if [[ -z "$src_dir" || -z "$DST_DIR" ]]; then
        echo "USAGE: sync_code <server_name> - Synchronizes files from source to destination using rsync/tar+ssh" >&2
        echo "" >&2
        echo "REQUIRED:" >&2
        echo "  server_name  SSH server name to sync to" >&2
        echo "" >&2
        echo "ENVIRONMENT VARIABLES:" >&2
        if [[ -z "$src_dir" ]]; then
            echo "ERROR: SRC_DIR environment variable is not set" >&2
            echo "INFO: Set it with: export SRC_DIR=/path/to/source" >&2
        fi
        if [[ -z "$DST_DIR" ]]; then
            echo "ERROR: DST_DIR environment variable is not set" >&2
            echo "INFO: Set it with: export DST_DIR=/path/to/destination" >&2
        fi
        echo "  IGNORE_DIRS  Comma-separated list of directories to exclude (optional)" >&2
        echo "               Example: IGNORE_DIRS=\".venv,.git,results\"" >&2
        return 1
    fi
    
    if [[ "$src_dir" == "." ]]; then
        src_dir="$(pwd)"
        echo "INFO: Converting SRC_DIR '.' to absolute path: '$src_dir'"
    elif [[ "$src_dir" == "./"* ]]; then
        src_dir="$(pwd)/${src_dir#./}"
        echo "INFO: Converting relative SRC_DIR to absolute path: '$src_dir'"
    elif [[ "$src_dir" != "/"* && "$src_dir" != *":"* ]]; then
        # Handle other relative paths (not starting with / and not remote)
        src_dir="$(pwd)/$src_dir"
        echo "INFO: Converting relative SRC_DIR to absolute path: '$src_dir'"
    fi
    
    if [[ "$dst_dir" == "." ]]; then
        dst_dir="$(pwd)"
        echo "INFO: Converting DST_DIR '.' to absolute path: '$dst_dir'"
    elif [[ "$dst_dir" == "./"* ]]; then
        dst_dir="$(pwd)/${dst_dir#./}"
        echo "INFO: Converting relative DST_DIR to absolute path: '$dst_dir'"
    elif [[ "$dst_dir" != "/"* && "$dst_dir" != *":"* ]]; then
        # Handle other relative paths (not starting with / and not remote)
        dst_dir="$(pwd)/$dst_dir"
        echo "INFO: Converting relative DST_DIR to absolute path: '$dst_dir'"
    fi
    
    src_dir="${src_dir%/}"
    dst_dir="${dst_dir%/}"
    
    if [[ ! -d "$src_dir" ]]; then
        echo "ERROR: Source directory '$src_dir' does not exist" >&2
        return 1
    fi
    
    if [[ ! -r "$src_dir" ]]; then
        echo "ERROR: Source directory '$src_dir' is not readable" >&2
        return 1
    fi
     
    if [[ "$dst_dir" != *":"* ]]; then
        if [[ "$(realpath "$src_dir" 2>/dev/null)" == "$(realpath "$dst_dir" 2>/dev/null)" ]]; then
            echo "ERROR: Source and destination directories are the same" >&2
            return 1
        fi
    fi
    
    local rsync_exclude_opts=""
    local tar_exclude_args=()
    if [[ -n "$IGNORE_DIRS" ]]; then
        echo "INFO: Processing IGNORE_DIRS: '$IGNORE_DIRS'"
        IFS=',' read -A ignore_array <<< "$IGNORE_DIRS"
        for dir in "${ignore_array[@]}"; do
            dir=$(echo "$dir" | xargs)
            if [[ -n "$dir" ]]; then
                # Remove leading ./ if present for consistency
                dir="${dir#./}"
                rsync_exclude_opts="$rsync_exclude_opts --exclude=$dir"
                # For tar, use array to properly handle arguments
                tar_exclude_args+=(--exclude="./$dir" --exclude="$dir")
                echo "INFO: Will exclude directory: '$dir' (and all subdirectories)"
            fi
        done
    fi
    
    echo "INFO: Starting sync from '$src_dir' to '$dst_dir'"
    
    # Show which files/directories will be synced
    echo "INFO: Analyzing files to sync..."
    local file_count=0
    local dir_count=0
    local total_size=0
    
    if [[ -n "$IGNORE_DIRS" ]]; then
        # Build find exclude options for preview
        local find_exclude_opts=""
        IFS=',' read -A ignore_array <<< "$IGNORE_DIRS"
        for dir in "${ignore_array[@]}"; do
            dir=$(echo "$dir" | xargs)
            if [[ -n "$dir" ]]; then
                find_exclude_opts="$find_exclude_opts -not -path '*/$dir' -not -path '*/$dir/*'"
            fi
        done
        
        # Count files and directories to sync (excluding ignored ones)
        eval "file_count=\$(find '$src_dir' -type f $find_exclude_opts 2>/dev/null | wc -l)"
        eval "dir_count=\$(find '$src_dir' -type d $find_exclude_opts 2>/dev/null | wc -l)"
        
        # Show sample of files that will be synced
        echo "INFO: Sample files to sync (first 10):"
        eval "find '$src_dir' -type f $find_exclude_opts 2>/dev/null" | head -10 | while read -r file; do
            rel_path="${file#$src_dir/}"
            size=$(stat -c%s "$file" 2>/dev/null || echo "0")
            echo "  - $rel_path ($(numfmt --to=iec-i --suffix=B $size))"
        done
        
        if [[ $file_count -gt 10 ]]; then
            echo "  ... and $((file_count - 10)) more files"
        fi
    else
        # No exclusions - count all files
        file_count=$(find "$src_dir" -type f 2>/dev/null | wc -l)
        dir_count=$(find "$src_dir" -type d 2>/dev/null | wc -l)
        
        echo "INFO: Sample files to sync (first 10):"
        find "$src_dir" -type f 2>/dev/null | head -10 | while read -r file; do
            rel_path="${file#$src_dir/}"
            size=$(stat -c%s "$file" 2>/dev/null || echo "0")
            echo "  - $rel_path ($(numfmt --to=iec-i --suffix=B $size))"
        done
        
        if [[ $file_count -gt 10 ]]; then
            echo "  ... and $((file_count - 10)) more files"
        fi
    fi
    
    echo "INFO: Total files to sync: $file_count"
    echo "INFO: Total directories to sync: $dir_count"
    
    if command -v rsync >/dev/null 2>&1; then
        echo "INFO: Using rsync for synchronization"
        
        if [[ "$dst_dir" == *":"* ]]; then
            echo "INFO: Testing remote connection..."
            local remote_host="${dst_dir%%:*}"
            if ! ssh -o ConnectTimeout=10 -o BatchMode=yes "$remote_host" 'exit' 2>/dev/null; then
                echo "ERROR: Cannot connect to remote host '$remote_host'" >&2
                echo "INFO: Make sure SSH key authentication is set up" >&2
                return 1
            fi
            
            if ! ssh "$remote_host" 'command -v rsync' >/dev/null 2>&1; then
                echo "WARNING: rsync not available on remote host, falling back to tar+ssh"
                rsync_available=false
            else
                rsync_available=true
            fi
        else
            rsync_available=true
        fi
        
        if [[ "$rsync_available" == "true" ]]; then
            if rsync -avz --progress --human-readable --stats $rsync_exclude_opts "$src_dir/" "$dst_dir/" 2>&1; then
                exit_code=$?
                if [[ $exit_code -eq 0 ]]; then
                    echo "SUCCESS: rsync completed successfully"
                    return 0
                else
                    echo "ERROR: rsync failed with exit code $exit_code" >&2
                    return $exit_code
                fi
            else
                exit_code=$?
                echo "ERROR: rsync failed with exit code $exit_code" >&2
                return $exit_code
            fi
        fi
    fi
    
    echo "WARNING: rsync not available or failed, falling back to tar+ssh"
    echo "WARNING: Destination files will be overwritten!"
    echo "WARNING: tar+ssh does not provide incremental sync like rsync"
    
    if ! command -v tar >/dev/null 2>&1; then
        echo "ERROR: tar is not available" >&2
        echo "INFO: Please install tar" >&2
        return 1
    fi
    
    if ! command -v ssh >/dev/null 2>&1; then
        echo "ERROR: ssh is not available" >&2
        echo "INFO: Please install openssh-client" >&2
        return 1
    fi
    
    if [[ "$dst_dir" == *":"* ]]; then
        local remote_host="${dst_dir%%:*}"
        local remote_path="${dst_dir#*:}"
        echo "INFO: Testing SSH connection to '$remote_host'..."
        if ! ssh -o ConnectTimeout=10 -o BatchMode=yes "$remote_host" 'exit' 2>/dev/null; then
            echo "ERROR: Cannot connect to remote host '$remote_host'" >&2
            echo "INFO: Make sure SSH key authentication is set up" >&2
            return 1
        fi
        
        echo "INFO: Ensuring remote directory '$remote_path' exists"
        if ! ssh "$remote_host" "mkdir -p '$remote_path'" 2>/dev/null; then
            echo "ERROR: Could not create remote directory '$remote_path'" >&2
            return 1
        fi
        
        echo "INFO: Using tar+ssh for synchronization with exclusions"
        echo "INFO: This may take longer than rsync for large directories"
        
        if (cd "$src_dir" && tar -cf - "${tar_exclude_args[@]}" .) | ssh "$remote_host" "cd '$remote_path' && tar -xf -"; then
            echo "SUCCESS: tar+ssh completed successfully"
            return 0
        else
            exit_code=$?
            echo "ERROR: tar+ssh failed with exit code $exit_code" >&2
            return $exit_code
        fi
    else
        echo "INFO: Using tar for local synchronization with exclusions"
        if ! mkdir -p "$dst_dir" 2>/dev/null; then
            echo "ERROR: Could not create destination directory '$dst_dir'" >&2
            return 1
        fi
        
        if (cd "$src_dir" && tar -cf - "${tar_exclude_args[@]}" .) | (cd "$dst_dir" && tar -xf -); then
            echo "SUCCESS: tar completed successfully"
            return 0
        else
            exit_code=$?
            echo "ERROR: tar failed with exit code $exit_code" >&2
            return $exit_code
        fi
    fi
}

_empty_trash () {
    if [[ -d $TRASH_DIR ]]; then 
        \rm -rf "${TRASH_DIR:?}"/*
        echo "Trash emptied."
    else
        echo "Trash directory does not exist."
    fi
}

_rm_completion() {
    _alternative 'files:file:_files'
}


autoload -U compinit
compinit

source $ZSH/oh-my-zsh.sh

# Define wifi function
wifi() {
    if [[ -f ~/.wifi ]]; then
        bash ~/.wifi "$@"
    else
        echo "wifi script not found at ~/.wifi"
    fi
}

# Define mounter function
mounter() {
    if [[ -f ~/.mounter ]]; then
        bash ~/.mounter "$@"
    else
        echo "mounter script not found at ~/.mounter"
    fi
}

# Define sshf function
sshf() {
    if [[ -f ~/.ssh-fzf ]]; then
        bash ~/.ssh-fzf "$@"
    else
        echo "ssh-fzf script not found at ~/.ssh-fzf"
    fi
}

# Ohmyzsh overrides some aliases, so we need to define them after sourcing it.
# Aliases
alias ls='lsd'
alias -- 'md-notes'='cd ~/Documents/md-notes/ && nvim .'
alias -- 'night'='brightnessctl s 1%'
alias -- 'opdf'='okular $(find ~/  -type f -iname '\''*pdf'\'' | fzf)'
alias -- 'fh'='eval $(history | fzf --tac --no-sort | sed "s/ *[0-9]* *//")'
alias -- 'fp'='fzf --preview "bat --color=always --style=numbers --line-range=:500 {}"'
alias -- 'rm'='_move_to_trash'
alias -- 'rot13'='tr '\''A-Za-z'\'' '\''N-ZA-Mn-za-m'\'''
alias -- 'sup'='power off'
alias -- 'sur'='systemctl reboot'
alias -- 'sus'='systemctl suspend'
alias -- 'tree'='eza --tree'
alias -- 'vi'='nvim'
alias -- 'vim'='nvim'
alias -- 'conda'='micromamba'
alias -- 'empty_trash'='_empty_trash'
alias -- 'cd'='z'

compdef _files _move_to_trash

zstyle ':fzf-tab:complete:*:*' fzf-preview 'less ${(Q)realpath}'
zstyle ':fzf-tab:complete:*:options' fzf-preview 
zstyle ':fzf-tab:complete:*:argument-1' fzf-preview
zstyle ':fzf-tab:complete:_move_to_trash:*' fzf-preview '[[ -f $realpath ]] && bat --color=always --style=numbers --line-range=:500 $realpath 2>/dev/null || [[ -d $realpath ]] && eza --tree --level=2 $realpath'

[[ -s "$HOME/.grc.zsh" ]] && source $HOME/.grc.zsh

# Named Directory Hashes

ZSH_HIGHLIGHT_HIGHLIGHTERS=(main brackets pattern cursor)
typeset -gA ZSH_HIGHLIGHT_STYLES
ZSH_HIGHLIGHT_STYLES[cursor]='bold'

ZSH_HIGHLIGHT_STYLES[alias]='fg=green,bold'
ZSH_HIGHLIGHT_STYLES[suffix-alias]='fg=green,bold'
ZSH_HIGHLIGHT_STYLES[builtin]='fg=green,bold'
ZSH_HIGHLIGHT_STYLES[function]='fg=green,bold'
ZSH_HIGHLIGHT_STYLES[command]='fg=green,bold'
ZSH_HIGHLIGHT_STYLES[precommand]='fg=green,bold'
ZSH_HIGHLIGHT_STYLES[hashed-command]='fg=green,bold'

# Ctrl-O opens zsh at the current location, and on exit, cd into ranger's last location.
ranger-cd() {
	tempfile=$(mktemp)
	ranger --choosedir="$tempfile" "${@:-$(pwd)}" < $TTY
	test -f "$tempfile" &&
	if [ "$(cat -- "$tempfile")" != "$(echo -n `pwd`)" ]; then
	cd -- "$(cat "$tempfile")"
	fi
	rm -f -- "$tempfile"
	# hacky way of transferring over previous command and updating the screen
	VISUAL=true zle edit-command-line
}

spf() {
    os=$(uname -s)

    # Linux
    if [[ "$os" == "Linux" ]]; then
        export SPF_LAST_DIR="${XDG_STATE_HOME:-$HOME/.local/state}/superfile/lastdir"
    fi

    # macOS
    if [[ "$os" == "Darwin" ]]; then
        export SPF_LAST_DIR="$HOME/Library/Application Support/superfile/lastdir"
    fi

    command spf "$@"

    [ ! -f "$SPF_LAST_DIR" ] || {
        . "$SPF_LAST_DIR"
        rm -f -- "$SPF_LAST_DIR" > /dev/null
    }
}

# fzf utilities
fshow() {
    git log --graph --color=always --format="%C(auto)%h%d %s %C(black)%C(bold)%cr" "$@" |
    fzf --ansi --no-sort --reverse --tiebreak=index --bind=ctrl-s:toggle-sort \
        --bind "ctrl-m:execute:
                (grep -o '[a-f0-9]\{7\}' | head -1 |
                xargs -I % sh -c 'git show --color=always % | less -R') << 'FZF-EOF'
                {}
FZF-EOF"
}

fkill() {
    local pid
    if [ "$UID" != "0" ]; then
        pid=$(ps -f -u $UID | sed 1d | fzf -m --header='Select processes to kill' | awk '{print $2}')
    else
        pid=$(ps -ef | sed 1d | fzf -m --header='Select processes to kill' | awk '{print $2}')
    fi

    if [ "x$pid" != "x" ]; then
        echo $pid | xargs kill -${1:-9}
    fi
}

# Quickly edit files in current directory
fe() {
    local file
    file=$(find . -type f 2>/dev/null | fzf --preview 'bat --color=always --style=numbers --line-range=:500 {}' --header='Select file to edit')
    if [[ -n $file ]]; then
        ${EDITOR:-nvim} "$file"
    fi
}

spf-cd() {
    spf
    VISUAL=true zle edit-command-line
}

zle -N ranger-cd
zle -N spf-cd
bindkey '^o' spf-cd

# Uncomment the following line to disable bi-weekly auto-update checks.
DISABLE_AUTO_UPDATE="true"

ZSH_CACHE_DIR=$HOME/.cache/oh-my-zsh
if [[ ! -d $ZSH_CACHE_DIR ]]; then
  mkdir $ZSH_CACHE_DIR
fi


# >>> mamba initialize >>>
# !! Contents within this block are managed by 'micromamba shell init' !!
export MAMBA_EXE='/usr/bin/micromamba';
export MAMBA_ROOT_PREFIX='/home/spanskiduh/.local/share/mamba';
__mamba_setup="$("$MAMBA_EXE" shell hook --shell zsh --root-prefix "$MAMBA_ROOT_PREFIX" 2> /dev/null)"
if [ $? -eq 0 ]; then
    eval "$__mamba_setup"
else
    alias micromamba="$MAMBA_EXE"  # Fallback on help from micromamba activate
fi
unset __mamba_setup
# <<< mamba initialize <<<
#

# Nvm
if [ -s "/usr/share/nvm/init-nvm.sh" ]; then
    source "/usr/share/nvm/init-nvm.sh"
fi
